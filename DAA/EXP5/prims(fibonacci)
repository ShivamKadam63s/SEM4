 #include <stdio.h>
 #include <stdlib.h>
 #include <stdbool.h>
 #include <limits.h>
 #include <math.h>
 
 #define INF INT_MAX
 
 // ----------------- Adjacency List Structures -----------------
 typedef struct AdjNode {
     int vertex;
     int weight;
     struct AdjNode* next;
 } AdjNode;
 
 typedef struct {
     AdjNode** head;
     int V;
 } Graph;
 
 AdjNode* createNode(int v, int w) {
     AdjNode* newNode = (AdjNode*)malloc(sizeof(AdjNode));
     newNode->vertex = v;
     newNode->weight = w;
     newNode->next = NULL;
     return newNode;
 }
 
 Graph* createGraph(int V) {
     Graph* graph = (Graph*)malloc(sizeof(Graph));
     graph->V = V;
     graph->head = (AdjNode**)malloc(V * sizeof(AdjNode*));
     for (int i = 0; i < V; i++) {
         graph->head[i] = NULL;
     }
     return graph;
 }
 
 void addEdge(Graph* graph, int u, int v, int w) {
     // u->v
     AdjNode* newNode = createNode(v, w);
     newNode->next = graph->head[u];
     graph->head[u] = newNode;
     // v->u (undirected)
     newNode = createNode(u, w);
     newNode->next = graph->head[v];
     graph->head[v] = newNode;
 }
 
 // ----------------- Fibonacci Heap Structures ----------------
 typedef struct FibNode {
     int vertex;
     int key;  // dist value for Prim
     int degree;
     struct FibNode* parent;
     struct FibNode* child;
     struct FibNode* left;
     struct FibNode* right;
     bool mark;
 } FibNode;
 
 typedef struct FibHeap {
     FibNode* min;
     int n;  // number of nodes
 } FibHeap;
 
 // Create a new Fibonacci node
 FibNode* makeFibNode(int vertex, int key) {
     FibNode* node = (FibNode*)malloc(sizeof(FibNode));
     node->vertex = vertex;
     node->key = key;
     node->degree = 0;
     node->parent = NULL;
     node->child = NULL;
     node->left = node;
     node->right = node;
     node->mark = false;
     return node;
 }
 
 // Create a new Fibonacci heap
 FibHeap* makeFibHeap() {
     FibHeap* heap = (FibHeap*)malloc(sizeof(FibHeap));
     heap->min = NULL;
     heap->n = 0;
     return heap;
 }
 
 // Insert a node into the root list of the Fibonacci heap
 void fibHeapInsert(FibHeap* H, FibNode* x) {
     x->degree = 0;
     x->parent = NULL;
     x->child = NULL;
     x->mark = false;
 
     // If heap is empty
     if (H->min == NULL) {
         H->min = x;
         x->left = x;
         x->right = x;
     } else {
         // Insert x into root list
         x->left = H->min;
         x->right = H->min->right;
         H->min->right->left = x;
         H->min->right = x;
         // Update min
         if (x->key < H->min->key) {
             H->min = x;
         }
     }
     H->n++;
 }
 
 // Link y to x (make y a child of x)
 void fibHeapLink(FibHeap* H, FibNode* y, FibNode* x) {
     // Remove y from root list
     y->left->right = y->right;
     y->right->left = y->left;
     // Make y a child of x
     y->parent = x;
     if (x->child == NULL) {
         x->child = y;
         y->left = y;
         y->right = y;
     } else {
         y->left = x->child;
         y->right = x->child->right;
         x->child->right->left = y;
         x->child->right = y;
     }
     x->degree++;
     y->mark = false;
 }
 
 // Consolidate the root list so that there is only one root of each degree
 void fibHeapConsolidate(FibHeap* H) {
     int D = (int)(floor(log2(H->n))) + 1;
     FibNode** A = (FibNode**)malloc(D * sizeof(FibNode*));
     for (int i = 0; i < D; i++) {
         A[i] = NULL;
     }
 
     // Make a list of root nodes
     FibNode* w = H->min;
     if (w != NULL) {
         FibNode* start = w;
         do {
             FibNode* x = w;
             int d = x->degree;
             while (A[d] != NULL) {
                 FibNode* y = A[d];
                 if (x->key > y->key) {
                     // swap
                     FibNode* temp = x;
                     x = y;
                     y = temp;
                 }
                 fibHeapLink(H, y, x);
                 A[d] = NULL;
                 d++;
             }
             A[d] = x;
             w = w->right;
         } while (w != start);
     }
 
     H->min = NULL;
     for (int i = 0; i < D; i++) {
         if (A[i] != NULL) {
             if (H->min == NULL) {
                 H->min = A[i];
                 H->min->left = H->min;
                 H->min->right = H->min;
             } else {
                 // insert A[i] into root list
                 A[i]->left = H->min;
                 A[i]->right = H->min->right;
                 H->min->right->left = A[i];
                 H->min->right = A[i];
                 if (A[i]->key < H->min->key) {
                     H->min = A[i];
                 }
             }
         }
     }
     free(A);
 }
 
 // Extract the min node from the heap
 FibNode* fibHeapExtractMin(FibHeap* H) {
     FibNode* z = H->min;
     if (z != NULL) {
         // For each child of z, add to root list
         FibNode* x = z->child;
         if (x != NULL) {
             FibNode* start = x;
             do {
                 FibNode* next = x->right;
                 // add x to root list
                 x->parent = NULL;
                 x->left = H->min;
                 x->right = H->min->right;
                 H->min->right->left = x;
                 H->min->right = x;
                 x = next;
             } while (x != start);
         }
 
         // Remove z from root list
         z->left->right = z->right;
         z->right->left = z->left;
 
         if (z == z->right) {
             H->min = NULL;
         } else {
             H->min = z->right;
             fibHeapConsolidate(H);
         }
         H->n--;
     }
     return z;
 }
 
 // Decrease key of node x to k
 void fibHeapDecreaseKey(FibHeap* H, FibNode* x, int k) {
     if (k > x->key) {
         fprintf(stderr, "Error: new key is greater than current key\n");
         return;
     }
     x->key = k;
     FibNode* y = x->parent;
     if (y != NULL && x->key < y->key) {
         // cut x from y
         // remove x from child list of y
         x->left->right = x->right;
         x->right->left = x->left;
         if (y->child == x) {
             if (x->right != x) {
                 y->child = x->right;
             } else {
                 y->child = NULL;
             }
         }
         y->degree--;
 
         // add x to root list
         x->parent = NULL;
         x->left = H->min;
         x->right = H->min->right;
         H->min->right->left = x;
         H->min->right = x;
         x->mark = false;
 
         // cascading cut
         FibNode* z = y;
         while (z->parent != NULL && z->mark) {
             FibNode* p = z->parent;
             // cut z from p
             z->left->right = z->right;
             z->right->left = z->left;
             if (p->child == z) {
                 if (z->right != z) {
                     p->child = z->right;
                 } else {
                     p->child = NULL;
                 }
             }
             p->degree--;
 
             // add z to root list
             z->parent = NULL;
             z->left = H->min;
             z->right = H->min->right;
             H->min->right->left = z;
             H->min->right = z;
             z->mark = false;
 
             z = p;
         }
         if (z->parent != NULL) {
             z->mark = true;
         }
     }
     if (x->key < H->min->key) {
         H->min = x;
     }
 }
 
 // A lookup table to find the FibNode* for each vertex quickly
 // (Alternatively, we could store FibNode* inside a separate array.)
 FibNode** fibNodes;
 
 // ------------------- Prim's Algorithm (Fib Heap) ------------
 void primMST_FibHeap(Graph* graph, int start) {
     int V = graph->V;
     int dist[V];
     int parent[V];
     bool inMST[V];
 
     // Initialize
     for (int i = 0; i < V; i++) {
         dist[i] = INF;
         parent[i] = -1;
         inMST[i] = false;
     }
     dist[start] = 0;
 
     // Create a Fibonacci heap
     FibHeap* H = makeFibHeap();
     fibNodes = (FibNode**)malloc(V * sizeof(FibNode*));
 
     // Insert all vertices in the Fibonacci heap
     for (int v = 0; v < V; v++) {
         FibNode* node = makeFibNode(v, dist[v]);
         fibHeapInsert(H, node);
         fibNodes[v] = node;
     }
 
     // The standard Primâ€™s main loop
     while (H->n > 0) {
         // Extract the min
         FibNode* minNode = fibHeapExtractMin(H);
         int u = minNode->vertex;
         inMST[u] = true;
 
         // For each neighbor (u, v)
         AdjNode* crawl = graph->head[u];
         while (crawl) {
             int v = crawl->vertex;
             int w = crawl->weight;
             if (!inMST[v] && w < dist[v]) {
                 dist[v] = w;
                 parent[v] = u;
                 // Decrease key of v in the fib heap
                 fibHeapDecreaseKey(H, fibNodes[v], w);
             }
             crawl = crawl->next;
         }
     }
 
     // Print MST edges and total cost
     int mstWeight = 0;
     printf("\nEdges in the MST (Prim's with Fibonacci Heap):\n");
     for (int v = 1; v < V; v++) {
         if (parent[v] != -1) {
             printf("Edge (%d -- %d) with weight %d\n",
                    parent[v], v, dist[v]);
             mstWeight += dist[v];
         }
     }
     printf("Total MST weight = %d\n", mstWeight);
     free(fibNodes);
 }
 
 int main() {
     int V, E;
     printf("=== Prim's Algorithm with Fibonacci Heap ===\n");
     printf("Enter number of vertices: ");
     scanf("%d", &V);
     printf("Enter number of edges: ");
     scanf("%d", &E);
 
     Graph* graph = createGraph(V);
 
     printf("Enter edges (u v weight):\n");
     for (int i = 0; i < E; i++) {
         int u, v, w;
         scanf("%d %d %d", &u, &v, &w);
         addEdge(graph, u, v, w);
     }
     primMST_FibHeap(graph, 0);
 
     return 0;
 }
